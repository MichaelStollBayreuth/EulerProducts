import Mathlib.Analysis.SpecialFunctions.Complex.LogBounds
import Mathlib.NumberTheory.DirichletCharacter.Orthogonality
import Mathlib.NumberTheory.LSeries.Linearity
import Mathlib.NumberTheory.LSeries.Nonvanishing
import Mathlib.RingTheory.RootsOfUnity.AlgebraicallyClosed

open scoped LSeries.notation

open Complex

/-!
### The logarithmic derivative of the L-function of a trivial character

We show that `s ‚Ü¶ -L'(œá) s / L(œá) s + 1 / (s - 1)` is continuous outside the zeros of `L(œá)`
when `œá` is a trivial Dirichlet character.
-/

namespace DirichletCharacter

-- probably should add the attribute where defined
attribute [local fun_prop] differentiableAt_LFunction

section trivial

variable (n : ‚Ñï) [NeZero n]

/-- The function obtained by "multiplying away" the pole of `L(œá)` for a trivial Dirichlet
character `œá`. Its (negative) logarithmic derivative is used in the Wiener-Ikehara Theorem
to prove the Prime Number Theorem version of Dirichlet's Theorem on primes in arithmetic
progressions. -/
noncomputable abbrev LFunctionTrivChar‚ÇÅ : ‚ÑÇ ‚Üí ‚ÑÇ :=
  Function.update (fun z ‚Ü¶ LFunctionTrivChar n z * (z - 1)) 1
    (‚àè p ‚àà n.primeFactors, (1 - (p : ‚ÑÇ)‚Åª¬π))

lemma LFunctionTrivChar‚ÇÅ_apply_of_ne_one {z : ‚ÑÇ} (hz : z ‚â† 1) :
    LFunctionTrivChar‚ÇÅ n z = LFunctionTrivChar n z * (z - 1) := by
  simp only [ne_eq, hz, not_false_eq_true, Function.update_noteq]

lemma LFunctionTrivChar‚ÇÅ_differentiable : Differentiable ‚ÑÇ (LFunctionTrivChar‚ÇÅ n) := by
  rw [‚Üê differentiableOn_univ,
    ‚Üê differentiableOn_compl_singleton_and_continuousAt_iff (c := 1) Filter.univ_mem]
  refine ‚ü®DifferentiableOn.congr (f := fun z ‚Ü¶ LFunctionTrivChar n z * (z - 1))
    (fun _ hz ‚Ü¶ DifferentiableAt.differentiableWithinAt <| by fun_prop (disch := simp_all [hz]))
    fun _ hz ‚Ü¶ ?_,
    continuousWithinAt_compl_self.mp ?_‚ü©
  ¬∑ simp only [Set.mem_diff, Set.mem_univ, Set.mem_singleton_iff, true_and] at hz
    simp only [ne_eq, hz, not_false_eq_true, Function.update_noteq]
  ¬∑ simpa only [mul_comm (LFunctionTrivChar ..), continuousWithinAt_compl_self,
      continuousAt_update_same] using LFunctionTrivChar_residue_one

lemma deriv_LFunctionTrivChar‚ÇÅ_apply_of_ne_one  {z : ‚ÑÇ} (hz : z ‚â† 1) :
    deriv (LFunctionTrivChar‚ÇÅ n) z =
      deriv (LFunctionTrivChar n) z * (z - 1) + LFunctionTrivChar n z := by
  have H : deriv (LFunctionTrivChar‚ÇÅ n) z =
      deriv (fun w ‚Ü¶ LFunctionTrivChar n w * (w - 1)) z := by
    refine Filter.EventuallyEq.deriv_eq <| Filter.eventuallyEq_iff_exists_mem.mpr ?_
    refine ‚ü®{w | w ‚â† 1}, IsOpen.mem_nhds isOpen_ne hz, fun w hw ‚Ü¶ ?_‚ü©
    simp only [ne_eq, Set.mem_setOf.mp hw, not_false_eq_true, Function.update_noteq]
  rw [H, deriv_mul (differentiableAt_LFunction _ z (.inl hz)) <| by fun_prop, deriv_sub_const,
    deriv_id'', mul_one]

lemma continuousOn_neg_logDeriv_LFunctionTrivChar‚ÇÅ :
    ContinuousOn (fun z ‚Ü¶ -deriv (LFunctionTrivChar‚ÇÅ n) z / LFunctionTrivChar‚ÇÅ n z)
      {z | z = 1 ‚à® LFunctionTrivChar n z ‚â† 0} := by
  simp_rw [neg_div]
  refine (((LFunctionTrivChar‚ÇÅ_differentiable n).contDiff.continuous_deriv le_rfl).continuousOn.div
    (LFunctionTrivChar‚ÇÅ_differentiable n).continuous.continuousOn fun w hw ‚Ü¶ ?_).neg
  rcases eq_or_ne w 1 with rfl | hw'
  ¬∑ simp only [Function.update_same]
    refine Finset.prod_ne_zero_iff.mpr fun p hp ‚Ü¶ ?_
    rw [sub_ne_zero, ne_eq, one_eq_inv]
    exact_mod_cast (Nat.prime_of_mem_primeFactors hp).ne_one
  ¬∑ rw [LFunctionTrivChar‚ÇÅ_apply_of_ne_one n hw', mul_ne_zero_iff]
    exact ‚ü®(Set.mem_setOf.mp hw).resolve_left hw', sub_ne_zero_of_ne hw'‚ü©

end trivial

section nontrivial

variable {n : ‚Ñï} [NeZero n] {œá : DirichletCharacter ‚ÑÇ n}

/-- The negative logarithmic derivative of the L-function of a nontrivial Dirichlet character
is continuous away from the zeros of the L-function. -/
lemma continuousOn_neg_logDeriv_LFunction_of_nontriv (hœá : œá ‚â† 1) :
    ContinuousOn (fun z ‚Ü¶ -deriv (LFunction œá) z / LFunction œá z) {z | LFunction œá z ‚â† 0} := by
  simp_rw [neg_div]
  have h := differentiable_LFunction hœá
  exact ((h.contDiff.continuous_deriv le_rfl).continuousOn.div
    h.continuous.continuousOn fun _ hw ‚Ü¶ hw).neg

end nontrivial

end DirichletCharacter


/-!
### The L-function of Œõ restricted to a residue class
-/

section arith_prog

namespace ArithmeticFunction

open DirichletCharacter

variable {q : ‚Ñï} [NeZero q] {a : ZMod q}

namespace vonMangoldt

variable (a) in
/-- The von Mangoldt function restricted to the prime residue class `a` mod `q`. -/
noncomputable abbrev residue_class : ‚Ñï ‚Üí ‚ÑÇ :=
  {n : ‚Ñï | (n : ZMod q) = a}.indicator (vonMangoldt ¬∑)

lemma residue_class_apply (ha : IsUnit a) (n : ‚Ñï) :
    residue_class a n =
      (q.totient : ‚ÑÇ)‚Åª¬π * ‚àë œá : DirichletCharacter ‚ÑÇ q, œá a‚Åª¬π * œá n * vonMangoldt n := by
  rw [eq_inv_mul_iff_mul_eq‚ÇÄ <| mod_cast (Nat.totient_pos.mpr q.pos_of_neZero).ne']
  simp only [residue_class, Set.indicator_apply, Set.mem_setOf_eq, mul_ite, mul_zero,
    ‚Üê Finset.sum_mul, sum_char_inv_mul_char_eq ‚ÑÇ ha n, eq_comm (a := a), ite_mul, zero_mul]

lemma residue_class_eq (ha : IsUnit a) :
    residue_class a = (q.totient : ‚ÑÇ)‚Åª¬π ‚Ä¢
      ‚àë œá : DirichletCharacter ‚ÑÇ q, œá a‚Åª¬π ‚Ä¢ (fun n : ‚Ñï ‚Ü¶ œá n * vonMangoldt n) := by
  ext1 n
  simpa only [Pi.smul_apply, Finset.sum_apply, smul_eq_mul, ‚Üê mul_assoc]
    using residue_class_apply ha n

/-- The L-series of the von Mangoldt function restricted to the prime residue class `a` mod `q`
is a linear combination of logarithmic derivatives of L-functions of the Dirichlet characters
mod `q` (on `re s ‚â• 1`). -/
lemma LSeries_residue_class_eq (ha : IsUnit a) {s : ‚ÑÇ} (hs : 1 < s.re) :
    LSeries (residue_class a) s =
      -(q.totient : ‚ÑÇ)‚Åª¬π * ‚àë œá : DirichletCharacter ‚ÑÇ q, œá a‚Åª¬π *
        (deriv (LFunction œá) s / LFunction œá s) := by
  simp only [deriv_LFunction_eq_deriv_LSeries _ hs, LFunction_eq_LSeries _ hs, neg_mul, ‚Üê mul_neg,
    ‚Üê Finset.sum_neg_distrib, ‚Üê neg_div, ‚Üê LSeries_twist_vonMangoldt_eq _ hs]
  rw [eq_inv_mul_iff_mul_eq‚ÇÄ <| mod_cast (Nat.totient_pos.mpr q.pos_of_neZero).ne']
  simp_rw [‚Üê LSeries_smul,
    ‚Üê LSeries_sum <| fun œá _ ‚Ü¶ (LSeriesSummable_twist_vonMangoldt œá hs).smul _]
  refine LSeries_congr s fun {n} _ ‚Ü¶ ?_
  simp only [Pi.smul_apply, residue_class_apply ha, smul_eq_mul, ‚Üê mul_assoc,
    mul_inv_cancel_of_invertible, one_mul, Finset.sum_apply, Pi.mul_apply]

end vonMangoldt

namespace DirichletsThm

variable (q)

variable (a) in
open Classical in
/-- The function `F` used in the Wiener-Ikehara Theorem to prove Dirichlet's Theorem. -/
noncomputable
abbrev auxFun (s : ‚ÑÇ) : ‚ÑÇ :=
  (q.totient : ‚ÑÇ)‚Åª¬π * (-deriv (LFunctionTrivChar‚ÇÅ q) s / LFunctionTrivChar‚ÇÅ q s -
    ‚àë œá ‚àà ({1}·∂ú : Finset (DirichletCharacter ‚ÑÇ q)), œá a‚Åª¬π * deriv (LFunction œá) s / LFunction œá s)

variable {q}

lemma auxFun_prop (ha : IsUnit a) :
    Set.EqOn (auxFun q a)
      (fun s ‚Ü¶ L (vonMangoldt.residue_class a) s - (q.totient : ‚ÑÇ)‚Åª¬π / (s - 1))
      {s | 1 < s.re} := by
  intro s hs
  simp only [Set.mem_setOf_eq] at hs
  simp only [vonMangoldt.LSeries_residue_class_eq ha hs, auxFun]
  rw [neg_div, ‚Üê neg_add', mul_neg, ‚Üê neg_mul,  div_eq_mul_one_div (q.totient : ‚ÑÇ)‚Åª¬π,
    sub_eq_add_neg, ‚Üê neg_mul, ‚Üê mul_add]
  congrm (_ * ?_)
  -- this should be easier, but `IsUnit.inv ha` does not work here
  have ha' : IsUnit a‚Åª¬π := isUnit_of_dvd_one ‚ü®a, (ZMod.inv_mul_of_unit a ha).symm‚ü©
  classical -- for `Fintype.sum_eq_add_sum_compl`
  rw [Fintype.sum_eq_add_sum_compl 1, MulChar.one_apply ha', one_mul, add_right_comm]
  simp only [mul_div_assoc]
  congrm (?_ + _)
  have hs‚ÇÅ : s ‚â† 1 := fun h ‚Ü¶ ((h ‚ñ∏ hs).trans_eq one_re).false
  rw [deriv_LFunctionTrivChar‚ÇÅ_apply_of_ne_one _ hs‚ÇÅ, LFunctionTrivChar‚ÇÅ_apply_of_ne_one _ hs‚ÇÅ]
  simp only [LFunctionTrivChar]
  rw [add_div, mul_div_mul_right _ _ (sub_ne_zero_of_ne hs‚ÇÅ)]
  conv_lhs => enter [2, 1]; rw [‚Üê mul_one (LFunction ..)]
  rw [mul_div_mul_left _ _ <| LFunction_ne_zero_of_one_le_re 1 (.inr hs‚ÇÅ) hs.le]

lemma auxFun_prop' (ha : IsUnit a) :
    Set.EqOn (L (vonMangoldt.residue_class a) - auxFun q a) (fun s ‚Ü¶ (q.totient : ‚ÑÇ)‚Åª¬π / (s - 1))
    {s | 1 < s.re} := by
  intro s hs
  simp only [Pi.sub_apply, auxFun_prop ha hs, sub_sub_cancel]

variable (a) in
/-- The L-series of the von Mangoldt function restricted to the prime residue class `a` mod `q`
is continuous on `re s ‚â• 1` except for a single pole at `s = 1` with residue `(q.totient)‚Åª¬π`. -/
lemma continuousOn_auxFun : ContinuousOn (auxFun q a) {s | 1 ‚â§ s.re} := by
  rw [show auxFun q a = fun s ‚Ü¶ _ from rfl]
  simp only [auxFun, sub_eq_add_neg]
  refine continuousOn_const.mul <| ContinuousOn.add ?_ ?_
  ¬∑ refine ContinuousOn.mono (continuousOn_neg_logDeriv_LFunctionTrivChar‚ÇÅ q) fun s hs ‚Ü¶ ?_
    have := LFunction_ne_zero_of_one_le_re (1 : DirichletCharacter ‚ÑÇ q) (s := s)
    tauto
  ¬∑ simp only [‚Üê Finset.sum_neg_distrib, mul_div_assoc, ‚Üê mul_neg, ‚Üê neg_div]
    refine continuousOn_finset_sum _ fun œá hœá ‚Ü¶ continuousOn_const.mul ?_
    replace hœá : œá ‚â† 1 := by simpa only [ne_eq, Finset.mem_compl, Finset.mem_singleton] using hœá
    exact ContinuousOn.mono (continuousOn_neg_logDeriv_LFunction_of_nontriv hœá)
      fun _ hs ‚Ü¶ LFunction_ne_zero_of_one_le_re œá (.inl hœá) hs

open Filter Topology in
lemma not_continuousAt_LSeries_residue_class (ha : IsUnit a) :
  ¬¨ ContinuousAt (L <| vonMangoldt.residue_class a) 1 := by
  by_contra H
  have h : (1 : ‚ÑÇ) ‚àà {s | 1 ‚â§ s.re} := by
    simp only [Set.mem_setOf_eq, one_re, le_refl]
  have H‚ÇÅ := H.continuousWithinAt (s := {s | 1 ‚â§ s.re})
  have H‚ÇÇ := (continuousOn_auxFun a).continuousWithinAt h
  have H‚ÇÉ := H‚ÇÅ.sub H‚ÇÇ


  stop
  have : Tendsto (L <| vonMangoldt.residue_class a) (ùìù[{s | 1 < s.re}] 1) (cocompact ‚ÑÇ) := by
    refine (tendsto_congr' <| eventuallyEq_nhdsWithin_of_eqOn <| auxFun_prop' ha).mpr ?_
    refine tendsto_nhdsWithin_mono_left (t := {s | 1 ‚â§ s.re}) (fun ‚¶És‚¶Ñ hs ‚Ü¶ le_of_lt hs) ?_

    sorry
  have inst : NeBot <| nhdsWithin (1 : ‚ÑÇ) {s | 1 < s.re} := by
    refine mem_closure_iff_nhdsWithin_neBot.mp ?_


    refine mem_closure_iff_nhds.mpr fun t ht ‚Ü¶ ?_
    refine Set.inter_nonempty.mpr ?_

    sorry
  refine not_continuousAt_of_tendsto this ?_ ?_
  ¬∑ sorry
  ¬∑ sorry

lemma abscissaOfAbsConv_vonMangoldt_residue_class (ha : IsUnit a) :
    LSeries.abscissaOfAbsConv (vonMangoldt.residue_class a) = 1 := by
  refine le_antisymm ?_ ?_
  ¬∑ rw [vonMangoldt.residue_class_eq ha]
    refine LSeries.abscissaOfAbsConv_le_of_forall_lt_LSeriesSummable fun h hy ‚Ü¶ ?_
    refine (LSeriesSummable.sum fun œá _ ‚Ü¶ LSeriesSummable.smul _ ?_).smul _
    exact œá.LSeriesSummable_mul <| ArithmeticFunction.LSeriesSummable_vonMangoldt <|
      by simp only [ofReal_re, hy]
  ¬∑ by_contra! H
    change LSeries.abscissaOfAbsConv (vonMangoldt.residue_class a) < (1 : ‚ÑÇ).re at H
    exact not_continuousAt_LSeries_residue_class ha <|
      HasDerivAt.continuousAt <| LSeries_hasDerivAt H

end DirichletsThm

end ArithmeticFunction

end arith_prog

namespace LSeries

/- lemma analyticOn_term (f : ‚Ñï ‚Üí ‚ÑÇ) (n : ‚Ñï) :
    AnalyticOn ‚ÑÇ (fun s ‚Ü¶ term f s n) Set.univ := by
  rcases eq_or_ne n 0 with rfl | hn
  ¬∑ simpa only [term_zero] using analyticOn_const
  ¬∑ have : NeZero n := ‚ü®hn‚ü©
    simp only [term_of_ne_zero hn]
    exact AnalyticOn.div analyticOn_const
      (analyticOn_univ_iff_differentiable.mpr <| differentiable_const_cpow_of_neZero n)
      fun s _ ‚Ü¶ by rw [cpow_def_of_ne_zero (mod_cast hn)]; exact exp_ne_zero _

/-- The L-series of a function with finite support is entire. -/
lemma analyticOn_of_finite_support {f : ‚Ñï ‚Üí ‚ÑÇ} (hf : ‚àÉ n, ‚àÄ m ‚â• n, f m = 0) :
    AnalyticOn ‚ÑÇ (LSeries f) Set.univ := by
  obtain ‚ü®n, hn‚ü© := hf
  have : LSeries f = fun s ‚Ü¶ ‚àë m ‚àà Finset.range n, term f s m := by
    refine funext fun s ‚Ü¶ tsum_eq_sum fun m hm ‚Ü¶ ?_
    refine (eq_or_ne m 0).casesOn (fun H ‚Ü¶ H ‚ñ∏ term_zero ..) (fun H ‚Ü¶ ?_)
    simp only [Finset.mem_range, not_lt] at hm
    simp only [term_of_ne_zero H, hn m hm, zero_div]
  exact this ‚ñ∏ Finset.analyticOn_sum _ fun m _ ‚Ü¶ analyticOn_term f m -/

end LSeries

open LSeries

-- We need a statement along the lines of:
-- if `f n = 0` for all large enough `n` *that are not perfect powers*, then
-- `LSeries f` is holomorphic at `s = 1`.

/-- **Dirichlet's Theorem** on primes in arithmetic progression: if `q` is a positive
integer and `a : ZMod q` is a unit, then there are infintely many prime numbers `p`
such that `(p : ZMod q) = a`. -/
theorem dirchlet_primes_in_arith_progression (q : ‚Ñï) [NeZero q] {a : ZMod q} (ha : IsUnit a) :
    ‚àÄ n : ‚Ñï, ‚àÉ p > n, p.Prime ‚àß (p : ZMod q) = a := by
  have H‚ÇÅ := ArithmeticFunction.DirichletsThm.auxFun_prop ha
  have H‚ÇÇ := ArithmeticFunction.DirichletsThm.continuousOn_auxFun a
  by_contra! H
  obtain ‚ü®n, hn‚ü© := H
  -- have key : abscissaOfAbsConv
  have H‚ÇÉ : ‚àÉ n : ‚Ñï, ‚àÄ m ‚â• n,
      ({(n : ‚Ñï) | (n : ZMod q) = a}.indicator ‚ÜóArithmeticFunction.vonMangoldt) m = 0 := by
    refine ‚ü®n + 1, fun m hm ‚Ü¶ ?_‚ü©
    by_cases H‚ÇÄ : (m : ZMod q) = a
    ¬∑ simp only [Set.mem_setOf_eq, H‚ÇÄ, Set.indicator_of_mem, ofReal_eq_zero]
      rw [ArithmeticFunction.vonMangoldt_eq_zero_iff]
      sorry
    ¬∑ simp only [Set.mem_setOf_eq, H‚ÇÄ, not_false_eq_true, Set.indicator_of_not_mem]
  sorry

/-!
### Statement of a version of the Wiener-Ikehara Theorem
-/

open Filter Topology Nat ArithmeticFunction in
/-- A version of the *Wiener-Ikehara Tauberian Theorem*: If `f` is a nonnegative arithmetic
function whose L-series has a simple pole at `s = 1` with residue `A` and otherwise extends
continuously to the closed half-plane `re s ‚â• 1`, then `‚àë n < N, f n` is asymptotic to `A*N`. -/
def WienerIkeharaTheorem : Prop :=
  ‚àÄ {f : ‚Ñï ‚Üí ‚Ñù} {A : ‚Ñù} {F : ‚ÑÇ ‚Üí ‚ÑÇ}, (‚àÄ n, 0 ‚â§ f n) ‚Üí
    Set.EqOn F (fun s ‚Ü¶ L ‚Üóf s - A / (s - 1)) {s | 1 < s.re} ‚Üí
    ContinuousOn F {s | 1 ‚â§ s.re} ‚Üí
    Tendsto (fun N : ‚Ñï ‚Ü¶ ((Finset.range N).sum f) / N) atTop (ùìù A)

/-!
### Derivation of the Prime Number Theorem and Dirichlet's Theorem from the Wiener-Ikehara Theorem
-/

open Filter ArithmeticFunction Topology ArithmeticFunction.DirichletsThm

/--  The *Wiener-Ikehara Theorem* implies *Dirichlet's Theorem* in the form that
`œà x ‚àº q.totient‚Åª¬π * x`, where `œà x = ‚àë n < x ‚àß n ‚â° a mod q, Œõ n`
and `Œõ` is the von Mangoldt function.

This is Theorem 2 in Section 2 of PNT+ (but using the `WIT` stub defined here). -/
theorem Dirichlet_vonMangoldt (WIT : WienerIkeharaTheorem) {q : ‚Ñï} [NeZero q] {a : ZMod q}
    (ha : IsUnit a) :
    Tendsto (fun N : ‚Ñï ‚Ü¶ (((Finset.range N).filter (fun n : ‚Ñï ‚Ü¶ (n : ZMod q) = a)).sum Œõ) / N)
      atTop (ùìù <| (q.totient : ‚Ñù)‚Åª¬π) := by
  classical
  have H N : ((Finset.range N).filter (fun n : ‚Ñï ‚Ü¶ (n : ZMod q) = a)).sum Œõ =
      (Finset.range N).sum ({n : ‚Ñï | (n : ZMod q) = a}.indicator Œõ) :=
    (Finset.sum_indicator_eq_sum_filter _ _ (fun _ ‚Ü¶ {n : ‚Ñï | n = a}) _).symm
  simp only [H]
  refine WIT (F := auxFun q a) (fun n ‚Ü¶ ?_) ?_ ?_
  ¬∑ exact Set.indicator_apply_nonneg fun _ ‚Ü¶ vonMangoldt_nonneg
  ¬∑ convert auxFun_prop ha with s n
    ¬∑ by_cases hn : n = a
      ¬∑ simp only [Set.mem_setOf_eq, hn, Set.indicator_of_mem]
      ¬∑ simp only [Set.mem_setOf_eq, hn, not_false_eq_true, Set.indicator_of_not_mem, ofReal_zero]
    ¬∑ rw [ofReal_inv, ofReal_natCast]
  ¬∑ exact continuousOn_auxFun a

/-- The *Wiener-Ikehara Theorem* implies the *Prime Number Theorem* in the form that
`œà x ‚àº x`, where `œà x = ‚àë n < x, Œõ n` and `Œõ` is the von Mangoldt function. -/
theorem PNT_vonMangoldt (WIT : WienerIkeharaTheorem) :
    Tendsto (fun N : ‚Ñï ‚Ü¶ ((Finset.range N).sum Œõ) / N) atTop (ùìù 1) := by
  convert Dirichlet_vonMangoldt WIT (q := 1) (a := 1) isUnit_one with n
  ¬∑ exact (Finset.filter_true_of_mem fun _ _ ‚Ü¶ Subsingleton.eq_one _).symm
  ¬∑ simp only [Nat.totient_one, Nat.cast_one, inv_one]
