import Mathlib.Analysis.PSeries
import Mathlib.Topology.CompletelyRegular
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.NumberTheory.LegendreSymbol.MulCharacter
import Mathlib.RingTheory.DedekindDomain.Basic
import Mathlib.Topology.EMetricSpace.Paracompact
import Mathlib.Topology.MetricSpace.Polish
import Mathlib.Analysis.Calculus.Deriv.Shift
import Mathlib.Analysis.Calculus.IteratedDeriv.Defs

/-!
### Auxiliary lemmas
-/

namespace Nat

-- #10025

lemma Prime.one_le {p : ‚Ñï} (hp : p.Prime) : 1 ‚â§ p := hp.one_lt.le

/- lemma pow_eq_one_iff {m n : ‚Ñï} : m ^ n = 1 ‚Üî m = 1 ‚à® n = 0 := by
  refine ‚ü®fun H ‚Ü¶ (eq_or_ne n 0).elim Or.inr fun h ‚Ü¶ Or.inl ?_, fun H ‚Ü¶ ?_‚ü©
  ¬∑ exact (_root_.pow_eq_one_iff h).mp H
  ¬∑ rcases H with rfl | rfl <;> simp -/

lemma Prime.pow_injective {p q m n : ‚Ñï} (hp : p.Prime) (hq : q.Prime)
    (h : p ^ (m + 1) = q ^ (n + 1)) : p = q ‚àß m = n := by
  have H := dvd_antisymm (Prime.dvd_of_dvd_pow hp <| h ‚ñ∏ dvd_pow_self p (succ_ne_zero m))
    (Prime.dvd_of_dvd_pow hq <| h.symm ‚ñ∏ dvd_pow_self q (succ_ne_zero n))
  exact ‚ü®H, succ_inj'.mp <| Nat.pow_right_injective hq.two_le (H ‚ñ∏ h)‚ü©

end Nat


namespace ZMod

-- #10028

open Nat

lemma eq_one_of_isUnit_natCast {n : ‚Ñï} (h : IsUnit (n : ZMod 0)) : n = 1 := by
  have := Int.isUnit_iff.mp h
  norm_cast at this
  exact this.resolve_right not_false

lemma isUnit_iff_coprime (m n : ‚Ñï) : IsUnit (m : ZMod n) ‚Üî m.Coprime n := by
  refine ‚ü®fun H ‚Ü¶ ?_, fun H ‚Ü¶ (unitOfCoprime m H).isUnit‚ü©
  have H' := val_coe_unit_coprime H.unit
  rw [IsUnit.unit_spec, val_nat_cast m, coprime_iff_gcd_eq_one] at H'
  rw [coprime_iff_gcd_eq_one, Nat.gcd_comm, ‚Üê H']
  exact gcd_rec n m

lemma isUnit_prime_of_not_dvd {n p : ‚Ñï} (hp : p.Prime) (h : ¬¨ p ‚à£ n) : IsUnit (p : ZMod n) := by
  rw [isUnit_iff_coprime]
  exact (Nat.Prime.coprime_iff_not_dvd hp).mpr h

-- needs primeFactors
lemma not_isUnit_of_mem_primeFactors {n p : ‚Ñï} (h : p ‚àà n.primeFactors) :
    ¬¨ IsUnit (p : ZMod n) := by
  rw [isUnit_iff_coprime]
  exact (Prime.dvd_iff_not_coprime <| prime_of_mem_primeFactors h).mp <| dvd_of_mem_primeFactors h

end ZMod


namespace Real

-- #10029

lemma log_le_mul_rpow {x Œµ : ‚Ñù} (hx : 0 ‚â§ x) (hŒµ : 0 < Œµ) : log x ‚â§ Œµ‚Åª¬π * x ^ Œµ := by
  rcases hx.eq_or_lt with rfl | h
  ¬∑ rw [log_zero, zero_rpow hŒµ.ne', mul_zero]
  suffices : Œµ * log x ‚â§ x ^ Œµ
  ¬∑ apply_fun (Œµ‚Åª¬π * ¬∑) at this using monotone_mul_left_of_nonneg (inv_pos.mpr hŒµ).le
    simp only at this
    rwa [‚Üê mul_assoc, inv_mul_cancel hŒµ.ne', one_mul] at this
  exact (log_rpow h Œµ).symm.trans_le <| (log_le_sub_one_of_pos <| rpow_pos_of_pos h Œµ).trans
    (sub_one_lt _).le

lemma log_ofNat_le_mul_rpow (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) : log n ‚â§ Œµ‚Åª¬π * n ^ Œµ :=
  log_le_mul_rpow n.cast_nonneg hŒµ

-- This can be generalized to series of decreasing nonnegative terms
lemma not_summable_indicator_one_div_nat_cast {m : ‚Ñï} (hm : m ‚â† 0) (k : ZMod m) :
    ¬¨ Summable (Set.indicator {n : ‚Ñï | (n : ZMod m) = k} fun n : ‚Ñï ‚Ü¶ (1 / n : ‚Ñù)) := by
  have : NeZero m := { out := hm }
  suffices : ¬¨ Summable fun n : ‚Ñï ‚Ü¶ (1 / (m * n + k.val) : ‚Ñù)
  ¬∑ set f : ‚Ñï ‚Üí ‚Ñù := Set.indicator {n : ‚Ñï | (n : ZMod m) = k} fun n : ‚Ñï ‚Ü¶ (1 / n : ‚Ñù)
    contrapose! this
    let g : ‚Ñï ‚Üí ‚Ñï := fun n ‚Ü¶ m * n + k.val
    have hg : Function.Injective g
    ¬∑ intro m n hmn
      simpa [g, hm] using hmn
    have hg' : ‚àÄ n ‚àâ Set.range g, f n = 0
    ¬∑ intro n hn
      contrapose! hn
      convert Set.mem_of_indicator_ne_zero hn
      ext n
      simp only [Set.mem_range, Set.mem_setOf_eq, ZMod.nat_coe_zmod_eq_iff]
      conv => enter [1, 1, y]; rw [add_comm, eq_comm]
    convert (Function.Injective.summable_iff hg hg').mpr this with n
    simp [g]
  by_contra! h
  refine not_summable_one_div_nat_cast <| (summable_nat_add_iff 2).mp <|
    (summable_mul_left_iff (one_div_ne_zero <| Nat.cast_ne_zero.mpr hm)).mp <|
    Summable.of_nonneg_of_le (fun n ‚Ü¶ by positivity) (fun n ‚Ü¶ ?_) <| (summable_nat_add_iff 1).mpr h
  field_simp
  rw [‚Üê ZMod.nat_cast_val k]
  gcongr
  norm_cast
  linarith only [ZMod.val_le k]

end Real


namespace Complex

-- #10034

@[simp, norm_cast]
lemma nat_cast_log {n : ‚Ñï} : Real.log n = log n := ofReal_nat_cast n ‚ñ∏ ofReal_log n.cast_nonneg

@[simp, norm_cast]
lemma nat_cast_arg {n : ‚Ñï} : arg n = 0 :=
  ofReal_nat_cast n ‚ñ∏ arg_ofReal_of_nonneg n.cast_nonneg

lemma nat_cast_mul_nat_cast_cpow (m n : ‚Ñï) (s : ‚ÑÇ) : (m * n : ‚ÑÇ) ^ s = m ^ s * n ^ s :=
  ofReal_nat_cast m ‚ñ∏ ofReal_nat_cast n ‚ñ∏ mul_cpow_ofReal_nonneg m.cast_nonneg n.cast_nonneg s

lemma nat_cast_cpow_nat_cast_mul (n m : ‚Ñï) (z : ‚ÑÇ) : (n : ‚ÑÇ) ^ (m * z) = ((n : ‚ÑÇ) ^ m) ^ z := by
  refine cpow_nat_mul' (x := n) (n := m) ?_ ?_ z
  ¬∑ simp only [nat_cast_arg, mul_zero, Left.neg_neg_iff, Real.pi_pos]
  ¬∑ simp only [nat_cast_arg, mul_zero, Real.pi_pos.le]

-- #10029 for the following five

lemma norm_ofNat_cpow_of_re_ne_zero (n : ‚Ñï) {s : ‚ÑÇ} (hs : s.re ‚â† 0) :
    ‚Äñ(n : ‚ÑÇ) ^ s‚Äñ = (n : ‚Ñù) ^ (s.re) := by
  rw [norm_eq_abs, ‚Üê ofReal_nat_cast, abs_cpow_eq_rpow_re_of_nonneg n.cast_nonneg hs]

lemma norm_ofNat_cpow_of_pos {n : ‚Ñï} (hn : 0 < n) (s : ‚ÑÇ) :
    ‚Äñ(n : ‚ÑÇ) ^ s‚Äñ = (n : ‚Ñù) ^ (s.re) := by
  rw [norm_eq_abs, ‚Üê ofReal_nat_cast, abs_cpow_eq_rpow_re_of_pos (Nat.cast_pos.mpr hn) _]

lemma norm_ofNat_cpow_pos_of_pos {n : ‚Ñï} (hn : 0 < n) (s : ‚ÑÇ) : 0 < ‚Äñ(n : ‚ÑÇ) ^ s‚Äñ :=
  (norm_ofNat_cpow_of_pos hn _).symm ‚ñ∏ Real.rpow_pos_of_pos (Nat.cast_pos.mpr hn) _

lemma norm_prime_cpow_le_one_half (p : Nat.Primes) {s : ‚ÑÇ} (hs : 1 < s.re) :
    ‚Äñ(p : ‚ÑÇ) ^ (-s)‚Äñ ‚â§ 1 / 2 := by
  rw [norm_ofNat_cpow_of_re_ne_zero p <| by rw [neg_re]; linarith only [hs]]
  refine (Real.rpow_le_rpow_of_nonpos zero_lt_two (Nat.cast_le.mpr p.prop.two_le) <|
    by rw [neg_re]; linarith only [hs]).trans ?_
  rw [one_div, ‚Üê Real.rpow_neg_one]
  exact Real.rpow_le_rpow_of_exponent_le one_le_two <| (neg_lt_neg hs).le

lemma one_sub_prime_cpow_ne_zero {p : ‚Ñï} (hp : p.Prime) {s : ‚ÑÇ} (hs : 1 < s.re) :
    1 - (p : ‚ÑÇ) ^ (-s) ‚â† 0 := by
  refine sub_ne_zero_of_ne fun H ‚Ü¶ ?_
  have := norm_prime_cpow_le_one_half ‚ü®p, hp‚ü© hs
  simp only at this
  rw [‚Üê H, norm_one] at this
  norm_num at this

lemma norm_ofNat_cpow_le_norm_ofNat_cpow_of_pos {n : ‚Ñï} (hn : 0 < n) {w z : ‚ÑÇ} (h : w.re ‚â§ z.re) :
    ‚Äñ(n : ‚ÑÇ) ^ w‚Äñ ‚â§ ‚Äñ(n : ‚ÑÇ) ^ z‚Äñ := by
  simp_rw [norm_ofNat_cpow_of_pos hn]
  exact Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast hn) h

--

lemma summable_re {Œ± : Type u_1} {f : Œ± ‚Üí ‚ÑÇ} (h : Summable f) : Summable fun x ‚Ü¶ (f x).re :=
  (Complex.hasSum_re h.hasSum).summable

lemma summable_im {Œ± : Type u_1} {f : Œ± ‚Üí ‚ÑÇ} (h : Summable f) : Summable fun x ‚Ü¶ (f x).im :=
  (Complex.hasSum_im h.hasSum).summable

-- #find_home summable_re -- [Mathlib.Analysis.Complex.Basic]

-- needs #10029
lemma norm_log_ofNat_le_mul_rpow (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) : ‚Äñlog n‚Äñ ‚â§ Œµ‚Åª¬π * n ^ Œµ := by
  rcases n.eq_zero_or_pos with rfl | h
  ¬∑ rw [Nat.cast_zero, Nat.cast_zero, log_zero, norm_zero, Real.zero_rpow hŒµ.ne', mul_zero]
  rw [norm_eq_abs, ‚Üê nat_cast_log, abs_ofReal,
    _root_.abs_of_nonneg <| Real.log_nonneg <| by exact_mod_cast Nat.one_le_of_lt h.lt]
  exact Real.log_ofNat_le_mul_rpow n hŒµ

end Complex


namespace MulChar

-- #10039

@[coe]
def toMonoidWithZeroHom {R R' : Type*} [CommMonoidWithZero R] [CommMonoidWithZero R']
    [Nontrivial R] (œá : MulChar R R') : R ‚Üí*‚ÇÄ R' where
      toFun := œá.toFun
      map_zero' := œá.map_zero
      map_one' := œá.map_one'
      map_mul' := œá.map_mul'

lemma one_apply {R : Type*} [CommMonoid R] (R' : Type*) [CommMonoidWithZero R'] {x : R}
    (hx : IsUnit x) : (1 : MulChar R R') x = 1 :=  one_apply_coe hx.unit

end MulChar


section Topology

namespace Asymptotics

open Filter

lemma isBigO_mul_iff_isBigO_div {Œ± F : Type*} [NormedField F] {l : Filter Œ±} {f g h : Œ± ‚Üí F}
    (hf : ‚àÄ·∂† x in l, f x ‚â† 0) :
    (fun x ‚Ü¶ f x * g x) =O[l] h ‚Üî g =O[l] (fun x ‚Ü¶ h x / f x) := by
  rw [isBigO_iff', isBigO_iff']
  refine ‚ü®fun ‚ü®c, hc, H‚ü© ‚Ü¶ ‚ü®c, hc, ?_‚ü©, fun ‚ü®c, hc, H‚ü© ‚Ü¶ ‚ü®c, hc, ?_‚ü©‚ü© <;>
  { refine H.congr <| Eventually.mp hf <| eventually_of_forall fun x hx ‚Ü¶ ?_
    rw [norm_mul, norm_div, ‚Üê mul_div_assoc, mul_comm]
    have hx' : ‚Äñf x‚Äñ > 0 := norm_pos_iff.mpr hx
    rw [le_div_iff hx', mul_comm] }

lemma isLittleO_id {F : Type*} [NormedField F] (s : Set F) :
    (id : F ‚Üí F) =o[nhdsWithin 0 s] (fun _ ‚Ü¶ (1 : F)) :=
  ((isLittleO_one_iff F).mpr tendsto_id).mono nhdsWithin_le_nhds

end Asymptotics


open Topology Asymptotics in
lemma DifferentiableAt.isBigO_of_eq_zero {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} (hf : DifferentiableAt ‚ÑÇ f z)
    (hz : f z = 0) : (fun w ‚Ü¶ f (w + z)) =O[ùìù 0] id := by
  rw [‚Üê zero_add z] at hf
  have := (hf.hasDerivAt.comp_add_const 0 z).differentiableAt.isBigO_sub
  simp only [zero_add, hz, sub_zero] at this
  exact this.trans <| isBigO_refl ..

open Topology Asymptotics Filter in
lemma ContinuousAt.isBigO {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} (hf : ContinuousAt f z) :
    (fun w ‚Ü¶ f (w + z)) =O[ùìù 0] (fun _ ‚Ü¶ (1 : ‚ÑÇ)) := by
  rw [isBigO_iff']
  replace hf : ContinuousAt (fun w ‚Ü¶ f (w + z)) 0
  ¬∑ convert (Homeomorph.comp_continuousAt_iff' (Homeomorph.addLeft (-z)) _ z).mp ?_
    ¬∑ simp
    ¬∑ simp [Function.comp_def, hf]
  simp_rw [Metric.continuousAt_iff', dist_eq_norm_sub, zero_add] at hf
  specialize hf 1 zero_lt_one
  refine ‚ü®‚Äñf z‚Äñ + 1, by positivity, ?_‚ü©
  refine Eventually.mp hf <| eventually_of_forall fun w hw ‚Ü¶ le_of_lt ?_
  calc ‚Äñf (w + z)‚Äñ
    _ ‚â§ ‚Äñf z‚Äñ + ‚Äñf (w + z) - f z‚Äñ := norm_le_insert' ..
    _ < ‚Äñf z‚Äñ + 1 := add_lt_add_left hw _
    _ = _ := by simp only [norm_one, mul_one]

open Topology in
lemma Complex.isBigO_comp_ofReal {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {x : ‚Ñù} (h : f =O[ùìù (x : ‚ÑÇ)] g) :
    (fun y : ‚Ñù ‚Ü¶ f y) =O[ùìù x] (fun y : ‚Ñù ‚Ü¶ g y) :=
  Asymptotics.IsBigO.comp_tendsto (k := fun y : ‚Ñù ‚Ü¶ (y : ‚ÑÇ)) h <|
    Continuous.tendsto Complex.continuous_ofReal x

open Topology in
lemma Complex.isBigO_comp_ofReal_nhds_ne {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {x : ‚Ñù} (h : f =O[ùìù[‚â†] (x : ‚ÑÇ)] g) :
    (fun y : ‚Ñù ‚Ü¶ f y) =O[ùìù[‚â†] x] (fun y : ‚Ñù ‚Ü¶ g y) :=
  Asymptotics.IsBigO.comp_tendsto (k := fun y : ‚Ñù ‚Ü¶ (y : ‚ÑÇ)) h <|
    ((hasDerivAt_id (x : ‚ÑÇ)).comp_ofReal).tendsto_punctured_nhds one_ne_zero

end Topology

-- #10087

namespace Fin

lemma snoc_zero {Œ± : Type*} (p : Fin 0 ‚Üí Œ±) (x : Œ±) :
    Fin.snoc p x = fun _ ‚Ü¶ x := by
  ext y
  have : Subsingleton (Fin (0 + 1)) := Fin.subsingleton_one
  simp only [Subsingleton.elim y (Fin.last 0), snoc_last]

end Fin

namespace Finset

lemma piecewise_same {Œ± : Type*} {Œ¥ : Œ± ‚Üí Sort*} (s : Finset Œ±)
    (f : (i : Œ±) ‚Üí Œ¥ i) [(j : Œ±) ‚Üí Decidable (j ‚àà s)] :
    s.piecewise f f = f := by
  ext i
  by_cases h : i ‚àà s <;> simp [h]

end Finset


namespace FormalMultilinearSeries

universe u v

variable {ùïú : Type*} {E : Type u} {F : Type v} [NontriviallyNormedField ùïú]
  [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F]
  (p : FormalMultilinearSeries ùïú E F)

/-- This series appears in `HasFPowerSeriesOnBall.fderiv` -/
noncomputable
def derivSeries : FormalMultilinearSeries ùïú E (E ‚ÜíL[ùïú] F) :=
  (continuousMultilinearCurryFin1 ùïú E F : (E[√ó1]‚ÜíL[ùïú] F) ‚ÜíL[ùïú] E ‚ÜíL[ùïú] F)
    |>.compFormalMultilinearSeries (p.changeOriginSeries 1)

open Fintype ContinuousLinearMap in
theorem derivSeries_apply_diag (n : ‚Ñï) (x : E) :
    derivSeries p n (fun _ ‚Ü¶ x) x = (n + 1) ‚Ä¢ p (n + 1) fun _ ‚Ü¶ x := by
  simp only [derivSeries, strongUniformity_topology_eq, compFormalMultilinearSeries_apply,
    changeOriginSeries, compContinuousMultilinearMap_coe, ContinuousLinearEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, Function.comp_apply, ContinuousMultilinearMap.sum_apply, map_sum,
    coe_sum', Finset.sum_apply, continuousMultilinearCurryFin1_apply, Matrix.zero_empty]
  convert Finset.sum_const _
  ¬∑ rw [Fin.snoc_zero, changeOriginSeriesTerm_apply, Finset.piecewise_same, add_comm]
  ¬∑ erw [‚Üê card, card_subtype, ‚Üê Finset.powersetCard_eq_filter, Finset.card_powersetCard, ‚Üê card,
      card_fin, eq_comm, add_comm, Nat.choose_succ_self_right]

end FormalMultilinearSeries

namespace HasFPowerSeriesOnBall

universe u v

open FormalMultilinearSeries ENNReal Nat

variable {ùïú : Type*} {E : Type u} {F : Type v} [NontriviallyNormedField ùïú]
  [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F]
  {p : FormalMultilinearSeries ùïú E F} {f : E ‚Üí F} {x : E} {r : ‚Ñù‚â•0‚àû}
  (h : HasFPowerSeriesOnBall f p x r) (y : E)

theorem iteratedFDeriv_zero_apply_diag :
    iteratedFDeriv ùïú 0 f x (fun _ ‚Ü¶ y) = p 0 (fun _ ‚Ü¶ y) := by
  convert (h.hasSum <| EMetric.mem_ball_self h.r_pos).tsum_eq.symm
  ¬∑ rw [iteratedFDeriv_zero_apply, add_zero]
  ¬∑ rw [tsum_eq_single 0 <| fun n hn ‚Ü¶ by haveI := NeZero.mk hn; exact (p n).map_zero]
    exact congr(p 0 $(Subsingleton.elim _ _))

open ContinuousLinearMap

private theorem factorial_smul' : ‚àÄ {F : Type max u v} [NormedAddCommGroup F]
    [NormedSpace ùïú F] [CompleteSpace F] {p : FormalMultilinearSeries ùïú E F}
    {f : E ‚Üí F}, HasFPowerSeriesOnBall f p x r ‚Üí
    n ! ‚Ä¢ p n (fun _ ‚Ü¶ y) = iteratedFDeriv ùïú n f x (fun _ ‚Ü¶ y) := by
  induction' n with n ih <;> intro F _ _ _ p f h
  ¬∑ rw [factorial_zero, one_smul, h.iteratedFDeriv_zero_apply_diag]
  ¬∑ rw [factorial_succ, mul_comm, mul_smul, ‚Üê derivSeries_apply_diag, ‚Üê smul_apply, derivSeries,
      ih h.fderiv, iteratedFDeriv_succ_apply_right]
    rfl

variable [CompleteSpace F]

theorem factorial_smul (n : ‚Ñï) :
    n ! ‚Ä¢ p n (fun _ ‚Ü¶ y) = iteratedFDeriv ùïú n f x (fun _ ‚Ü¶ y) := by
  cases n
  ¬∑ rw [factorial_zero, one_smul, h.iteratedFDeriv_zero_apply_diag]
  ¬∑ erw [factorial_succ, mul_comm, mul_smul, ‚Üê derivSeries_apply_diag, ‚Üê smul_apply,
      factorial_smul'.{_,u,v} _ h.fderiv, iteratedFDeriv_succ_apply_right]
    rfl

theorem hasSum_iteratedFDeriv [CharZero ùïú] {y : E} (hy : y ‚àà EMetric.ball 0 r) :
    HasSum (fun n ‚Ü¶ (n ! : ùïú)‚Åª¬π ‚Ä¢ iteratedFDeriv ùïú n f x fun _ ‚Ü¶ y) (f (x + y)) := by
  convert h.hasSum hy with n
  rw [‚Üê h.factorial_smul y n, smul_comm, ‚Üê smul_assoc, nsmul_eq_mul,
    mul_inv_cancel <| cast_ne_zero.mpr n.factorial_ne_zero, one_smul]

/- We can't quite show
  `HasFPowerSeriesOnBall f (fun n ‚Ü¶ (1 / n !) ‚Ä¢ iteratedFDeriv ùïú n f x) x r`
  because `r_le` requires bounding the norm of a multilinear map using values on
  the diagonal, so some polarization identity would be required. -/

end HasFPowerSeriesOnBall


namespace Complex

open BigOperators Nat

variable {E : Type u} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E]

/-- A function that is complex differentiable on the open ball of radius `r` around `c`
is given by evaluating its Taylor series at `c` on this open ball. -/
lemma hasSum_taylorSeries_on_ball {f : ‚ÑÇ ‚Üí E} ‚¶Ér : NNReal‚¶Ñ
    (hf : DifferentiableOn ‚ÑÇ f (Metric.ball c r)) ‚¶Éz : ‚ÑÇ‚¶Ñ (hz : z ‚àà Metric.ball c r) :
    HasSum (fun n : ‚Ñï ‚Ü¶ (n ! : ‚ÑÇ)‚Åª¬π ‚Ä¢ (z - c) ^ n ‚Ä¢ iteratedDeriv n f c) (f z) := by
  obtain ‚ü®r', hr', hr'‚ÇÄ, hzr'‚ü© : ‚àÉ r' < r, 0 < r' ‚àß z ‚àà Metric.ball c r'
  ¬∑ obtain ‚ü®r', h‚ÇÅ, h‚ÇÇ‚ü© := exists_between (Metric.mem_ball'.mp hz)
    lift r' to NNReal using dist_nonneg.trans h‚ÇÅ.le
    exact ‚ü®r', h‚ÇÇ, pos_of_gt h‚ÇÅ, Metric.mem_ball'.mpr h‚ÇÅ‚ü©
  have hz' : z - c ‚àà EMetric.ball 0 r'
  ¬∑ rw [Metric.emetric_ball_nnreal]
    exact mem_ball_zero_iff.mpr hzr'
  have H := (hf.mono <| Metric.closedBall_subset_ball hr').hasFPowerSeriesOnBall hr'‚ÇÄ
      |>.hasSum_iteratedFDeriv hz'
  simp only [add_sub_cancel'_right] at H
  convert H using 4 with n
  simpa only [iteratedDeriv_eq_iteratedFDeriv, smul_eq_mul, mul_one, Finset.prod_const,
    Finset.card_fin]
    using ((iteratedFDeriv ‚ÑÇ n f c).map_smul_univ (fun _ ‚Ü¶ z - c) (fun _ ‚Ü¶ 1)).symm

-- import Mathlib.Analysis.Complex.CauchyIntegral

/-- A function that is complex differentiable on the open ball of radius `r` around `c`
is given by evaluating its Taylor series at `c` on theis open ball. -/
lemma taylorSeries_eq_on_ball {f : ‚ÑÇ ‚Üí E} ‚¶Ér : NNReal‚¶Ñ
    (hf : DifferentiableOn ‚ÑÇ f (Metric.ball c r)) ‚¶Éz : ‚ÑÇ‚¶Ñ (hz : z ‚àà Metric.ball c r) :
    ‚àë' n : ‚Ñï, (n ! : ‚ÑÇ)‚Åª¬π ‚Ä¢ (z - c) ^ n ‚Ä¢ iteratedDeriv n f c = f z :=
  (hasSum_taylorSeries_on_ball hf hz).tsum_eq

/-- A function that is complex differentiable on the open ball of radius `r` around `c`
is given by evaluating its Taylor series at `c` on this open ball. -/
lemma taylorSeries_eq_on_ball' {f : ‚ÑÇ ‚Üí ‚ÑÇ} ‚¶Ér : NNReal‚¶Ñ
    (hf : DifferentiableOn ‚ÑÇ f (Metric.ball c r)) ‚¶Éz : ‚ÑÇ‚¶Ñ (hz : z ‚àà Metric.ball c r) :
    ‚àë' n : ‚Ñï, (n ! : ‚ÑÇ)‚Åª¬π * iteratedDeriv n f c * (z - c) ^ n = f z := by
  convert taylorSeries_eq_on_ball hf hz using 3 with n
  rw [mul_right_comm, smul_eq_mul, smul_eq_mul, mul_assoc]

/-- A function that is complex differentiable on the complex plane is given by evaluating
its Taylor series at any point `c`. -/
lemma hasSum_taylorSeries_of_entire {f : ‚ÑÇ ‚Üí E} (hf : Differentiable ‚ÑÇ f) (c z : ‚ÑÇ) :
    HasSum (fun n : ‚Ñï ‚Ü¶ (n ! : ‚ÑÇ)‚Åª¬π ‚Ä¢ (z - c) ^ n ‚Ä¢ iteratedDeriv n f c) (f z) := by
  have hf' : DifferentiableOn ‚ÑÇ f
      (Metric.ball c (‚ü®1 + ‚Äñz - c‚Äñ, add_nonneg zero_le_one <| norm_nonneg _‚ü© : NNReal)) :=
    hf.differentiableOn
  refine hasSum_taylorSeries_on_ball hf' ?_
  rw [mem_ball_iff_norm, NNReal.coe_mk, lt_add_iff_pos_left]
  exact zero_lt_one

/-- A function that is complex differentiable on the complex plane is given by evaluating
its Taylor series at any point `c`. -/
lemma taylorSeries_eq_of_entire {f : ‚ÑÇ ‚Üí E} (hf : Differentiable ‚ÑÇ f) (c z : ‚ÑÇ) :
    ‚àë' n : ‚Ñï, (n ! : ‚ÑÇ)‚Åª¬π ‚Ä¢ (z - c) ^ n ‚Ä¢ iteratedDeriv n f c = f z :=
  (hasSum_taylorSeries_of_entire hf c z).tsum_eq

/-- A function that is complex differentiable on the complex plane is given by evaluating
its Taylor series at any point `c`. -/
lemma taylorSeries_eq_of_entire' {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : Differentiable ‚ÑÇ f) (c z : ‚ÑÇ) :
    ‚àë' n : ‚Ñï, (n ! : ‚ÑÇ)‚Åª¬π * iteratedDeriv n f c * (z - c) ^ n = f z := by
  convert taylorSeries_eq_of_entire hf c z using 3 with n
  rw [mul_right_comm, smul_eq_mul, smul_eq_mul, mul_assoc]

end Complex

-- (until here: #10087)


namespace deriv

variable {ùïú F : Type*} [NontriviallyNormedField ùïú] [NormedAddCommGroup F] [NormedSpace ùïú F]

open ContinuousLinearMap in
lemma comp_neg (f : ùïú ‚Üí F) (a : ùïú) : deriv (fun x ‚Ü¶ f (-x)) a = -deriv f (-a) := by
  by_cases h : DifferentiableAt ùïú f (-a)
  ¬∑ simp_rw [‚Üê fderiv_deriv]
    change (fderiv ùïú (f ‚àò fun x ‚Ü¶ -x) a) 1 = _
    rw [fderiv.comp _ h differentiable_neg.differentiableAt, show @Neg.neg ùïú _ = (- ¬∑) from rfl,
      coe_comp', Function.comp_apply, fderiv_neg, fderiv_id', neg_apply, coe_id', id_eq, map_neg]
  ¬∑ have H : ¬¨ DifferentiableAt ùïú (fun x ‚Ü¶ f (-x)) a
    ¬∑ contrapose! h
      rw [‚Üê neg_neg a] at h
      convert h.comp (-a) differentiable_neg.differentiableAt
      ext
      simp only [Function.comp_apply, neg_neg]
    rw [deriv_zero_of_not_differentiableAt h, deriv_zero_of_not_differentiableAt H, neg_zero]

-- #find_home comp_neg -- [Mathlib.Analysis.Calculus.Deriv.Add]

/-- A variant of `deriv_const_smul` without differentiability assumption when the scalar
multiplication is by field elements. -/
lemma const_smul {f : ùïú ‚Üí F} {x : ùïú} {R : Type*} [Field R] [Module R F] [SMulCommClass ùïú R F]
    [ContinuousConstSMul R F] (c : R) :
    deriv (fun y ‚Ü¶ c ‚Ä¢ f y) x = c ‚Ä¢ deriv f x := by
  by_cases hf : DifferentiableAt ùïú f x
  ¬∑ exact deriv_const_smul c hf
  ¬∑ rcases eq_or_ne c 0 with rfl | hc
    ¬∑ simp only [zero_smul, deriv_const']
    ¬∑ have H : ¬¨DifferentiableAt ùïú (fun y ‚Ü¶ c ‚Ä¢ f y) x
      ¬∑ contrapose! hf
        change DifferentiableAt ùïú (fun y ‚Ü¶ f y) x
        conv => enter [2, y]; rw [‚Üê inv_smul_smul‚ÇÄ hc (f y)]
        exact DifferentiableAt.const_smul hf c‚Åª¬π
      rw [deriv_zero_of_not_differentiableAt hf, deriv_zero_of_not_differentiableAt H, smul_zero]

-- #find_home const_smul -- [Mathlib.Analysis.Calculus.Deriv.Mul]

end deriv


namespace iteratedDeriv

variable {ùïú F : Type*} [NontriviallyNormedField ùïú] [NormedAddCommGroup F] [NormedSpace ùïú F]

lemma neg (n : ‚Ñï) (f : ùïú ‚Üí F) (a : ùïú) :
    iteratedDeriv n (fun x ‚Ü¶ -(f x)) a = -(iteratedDeriv n f a) := by
  induction' n with n ih generalizing a
  ¬∑ simp only [Nat.zero_eq, iteratedDeriv_zero]
  ¬∑ have ih' : iteratedDeriv n (fun x ‚Ü¶ -f x) = fun x ‚Ü¶ -iteratedDeriv n f x := funext ih
    rw [iteratedDeriv_succ, iteratedDeriv_succ, ih', deriv.neg]

lemma comp_neg (n : ‚Ñï) (f : ùïú ‚Üí F) (a : ùïú) :
    iteratedDeriv n (fun x ‚Ü¶ f (-x)) a = (-1 : ùïú) ^ n ‚Ä¢ iteratedDeriv n f (-a) := by
  induction' n with n ih generalizing a
  ¬∑ simp only [Nat.zero_eq, iteratedDeriv_zero, pow_zero, one_smul]
  ¬∑ have ih' : iteratedDeriv n (fun x ‚Ü¶ f (-x)) = fun x ‚Ü¶ (-1 : ùïú) ^ n ‚Ä¢ iteratedDeriv n f (-x) :=
      funext ih
    rw [iteratedDeriv_succ, iteratedDeriv_succ, ih', pow_succ, neg_mul, one_mul,
      deriv.comp_neg (f := fun x ‚Ü¶ (-1 : ùïú) ^ n ‚Ä¢ iteratedDeriv n f x), deriv.const_smul, neg_smul]

end iteratedDeriv


namespace Complex
-- see https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Differentiability.20of.20the.20natural.20map.20.E2.84.9D.20.E2.86.92.20.E2.84.82/near/418095234

lemma hasDerivAt_ofReal (x : ‚Ñù) : HasDerivAt ofReal' 1 x :=
  HasDerivAt.ofReal_comp <| hasDerivAt_id x

lemma deriv_ofReal (x : ‚Ñù) : deriv ofReal' x = 1 :=
  (hasDerivAt_ofReal x).deriv

lemma differentiableAt_ofReal (x : ‚Ñù) : DifferentiableAt ‚Ñù ofReal' x :=
  (hasDerivAt_ofReal x).differentiableAt

lemma differentiable_ofReal : Differentiable ‚Ñù ofReal' :=
  ofRealCLM.differentiable

-- #find_home hasDerivAt_ofReal -- [Mathlib.Analysis.SpecialFunctions.NonIntegrable]
-- Mathlib.Analysis.Complex.RealDeriv ?

end Complex

lemma DifferentiableAt.comp_ofReal {e : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚Ñù} (hf : DifferentiableAt ‚ÑÇ e z) :
    DifferentiableAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ e x) z :=
  hf.hasDerivAt.comp_ofReal.differentiableAt

lemma deriv.comp_ofReal {e : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚Ñù} (hf : DifferentiableAt ‚ÑÇ e z) :
    deriv (fun x : ‚Ñù ‚Ü¶ e x) z = deriv e z :=
  hf.hasDerivAt.comp_ofReal.deriv

lemma Differentiable.comp_ofReal {e : ‚ÑÇ ‚Üí ‚ÑÇ} (h : Differentiable ‚ÑÇ e) :
    Differentiable ‚Ñù (fun x : ‚Ñù ‚Ü¶ e x) :=
  fun _ ‚Ü¶ h.differentiableAt.comp_ofReal

lemma DifferentiableAt.ofReal_comp {z : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} (hf : DifferentiableAt ‚Ñù f z) :
    DifferentiableAt ‚Ñù (fun (y : ‚Ñù) => (f y : ‚ÑÇ)) z :=
  hf.hasDerivAt.ofReal_comp.differentiableAt

lemma Differentiable.ofReal_comp {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) :
    Differentiable ‚Ñù (fun (y : ‚Ñù) => (f y : ‚ÑÇ)) :=
  fun _ ‚Ü¶ hf.differentiableAt.ofReal_comp

open Complex ContinuousLinearMap in
lemma HasDerivAt.of_hasDerivAt_ofReal_comp {z : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} {u : ‚ÑÇ}
    (hf : HasDerivAt (fun y ‚Ü¶ (f y : ‚ÑÇ)) u z) :
    ‚àÉ u' : ‚Ñù, u = u' ‚àß HasDerivAt f u' z := by
  lift u to ‚Ñù
  ¬∑ have H := (imCLM.hasFDerivAt.comp z hf.hasFDerivAt).hasDerivAt.deriv
    simp only [Function.comp_def, imCLM_apply, ofReal_im, deriv_const] at H
    rwa [eq_comm, comp_apply, imCLM_apply, smulRight_apply, one_apply, one_smul] at H
  refine ‚ü®u, rfl, ?_‚ü©
  convert (reCLM.hasFDerivAt.comp z hf.hasFDerivAt).hasDerivAt
  rw [comp_apply, smulRight_apply, one_apply, one_smul, reCLM_apply, ofReal_re]

lemma DifferentiableAt.ofReal_comp_iff {z : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} :
    DifferentiableAt ‚Ñù (fun (y : ‚Ñù) => (f y : ‚ÑÇ)) z ‚Üî DifferentiableAt ‚Ñù f z := by
  refine ‚ü®fun H ‚Ü¶ ?_, ofReal_comp‚ü©
  obtain ‚ü®u, _, hu‚ÇÇ‚ü© := H.hasDerivAt.of_hasDerivAt_ofReal_comp
  exact HasDerivAt.differentiableAt hu‚ÇÇ

lemma Differentiable.ofReal_comp_iff {f : ‚Ñù ‚Üí ‚Ñù} :
    Differentiable ‚Ñù (fun (y : ‚Ñù) => (f y : ‚ÑÇ)) ‚Üî Differentiable ‚Ñù f :=
  forall_congr' fun _ ‚Ü¶ DifferentiableAt.ofReal_comp_iff

lemma deriv.ofReal_comp {z : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} :
    deriv (fun (y : ‚Ñù) => (f y : ‚ÑÇ)) z = deriv f z := by
  by_cases hf : DifferentiableAt ‚Ñù f z
  ¬∑ exact hf.hasDerivAt.ofReal_comp.deriv
  ¬∑ have hf' := mt DifferentiableAt.ofReal_comp_iff.mp hf
    rw [deriv_zero_of_not_differentiableAt hf, deriv_zero_of_not_differentiableAt hf',
      Complex.ofReal_zero]

-- #10112

namespace Complex

section OrderInstance

open scoped ComplexOrder

instance : OrderClosedTopology ‚ÑÇ where
  isClosed_le' := by
    simp_rw [le_def, Set.setOf_and]
    refine IsClosed.inter (isClosed_le ?_ ?_) (isClosed_eq ?_ ?_) <;> continuity

lemma monotone_ofReal : Monotone ofReal' := by
  intro x y hxy
  simp only [ofReal_eq_coe, real_le_real, hxy]

end OrderInstance

--


open Nat

/-- A function that is complex differentiable on the closed ball of radius `r` around `c`,
where `c` is real, and all whose iterated derivatives at `c` are real can be give by a real
differentiable function on the real open interval from `c-r` to `c+r`. -/
lemma realValued_of_iteratedDeriv_real_on_ball {f : ‚ÑÇ ‚Üí ‚ÑÇ} ‚¶Ér : NNReal‚¶Ñ {c : ‚Ñù}
    (hf : DifferentiableOn ‚ÑÇ f (Metric.ball c r)) ‚¶ÉD : ‚Ñï ‚Üí ‚Ñù‚¶Ñ
    (hd : ‚àÄ n, iteratedDeriv n f c = D n) :
    ‚àÉ F : ‚Ñù ‚Üí ‚Ñù, DifferentiableOn ‚Ñù F (Set.Ioo (c - r) (c + r)) ‚àß
      Set.EqOn (f ‚àò ofReal') (ofReal' ‚àò F) (Set.Ioo (c - r) (c + r)) := by
  have Hz : ‚àÄ x ‚àà Set.Ioo (c - r) (c + r), (x : ‚ÑÇ) ‚àà Metric.ball (c : ‚ÑÇ) r
  ¬∑ intro x hx
    refine Metric.mem_ball.mpr ?_
    rw [dist_eq, ‚Üê ofReal_sub, abs_ofReal, abs_sub_lt_iff, sub_lt_iff_lt_add', sub_lt_comm]
    exact and_comm.mpr hx
  have H := taylorSeries_eq_on_ball' hf
  refine ‚ü®fun x ‚Ü¶ ‚àë' (n : ‚Ñï), (‚Üën !)‚Åª¬π * (D n) * (x - c) ^ n, fun x hx ‚Ü¶ ?_, fun x hx ‚Ü¶ ?_‚ü©
  ¬∑ have Hx := Hz _ hx
    refine DifferentiableAt.differentiableWithinAt ?_
    replace hf := ((hf x Hx).congr (fun _ hz ‚Ü¶ H hz) (H Hx)).differentiableAt
      (Metric.isOpen_ball.mem_nhds Hx) |>.comp_ofReal
    simp_rw [hd, ‚Üê ofReal_sub, ‚Üê ofReal_nat_cast, ‚Üê ofReal_inv, ‚Üê ofReal_pow, ‚Üê ofReal_mul,
      ‚Üê ofReal_tsum] at hf
    exact DifferentiableAt.ofReal_comp_iff.mp hf
  ¬∑ simp only [Function.comp_apply, ‚Üê H (Hz _ hx), hd, ofReal_tsum]
    push_cast
    rfl

/-- A function that is complex differentiable on the complex plane and all whose iterated
derivatives at a real point `c` are real can be given by a real differentiable function
on the real line. -/
lemma realValued_of_iteratedDeriv_real {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : Differentiable ‚ÑÇ f) {c : ‚Ñù} {D : ‚Ñï ‚Üí ‚Ñù}
    (hd : ‚àÄ n, iteratedDeriv n f c = D n) :
    ‚àÉ F : ‚Ñù ‚Üí ‚Ñù, Differentiable ‚Ñù F ‚àß (f ‚àò ofReal') = (ofReal' ‚àò F) := by
  have H := taylorSeries_eq_of_entire' hf c
  simp_rw [hd] at H
  refine ‚ü®fun x ‚Ü¶ ‚àë' (n : ‚Ñï), (‚Üën !)‚Åª¬π * (D n) * (x - c) ^ n, ?_, ?_‚ü©
  ¬∑ have := hf.comp_ofReal
    simp_rw [‚Üê H, ‚Üê ofReal_sub, ‚Üê ofReal_nat_cast, ‚Üê ofReal_inv, ‚Üê ofReal_pow, ‚Üê ofReal_mul,
      ‚Üê ofReal_tsum] at this
    exact Differentiable.ofReal_comp_iff.mp this
  ¬∑ ext x
    simp only [Function.comp_apply, ofReal_eq_coe, ‚Üê H, ofReal_tsum]
    push_cast
    rfl

open scoped ComplexOrder

/-- An entire function whose iterated derivatives at zero are all nonnegative real has nonnegative
real values for nonnegative real arguments. -/
theorem nonneg_of_iteratedDeriv_nonneg {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : Differentiable ‚ÑÇ f)
    (h : ‚àÄ n, 0 ‚â§ iteratedDeriv n f 0) ‚¶Éz : ‚ÑÇ‚¶Ñ (hz : 0 ‚â§ z) : 0 ‚â§ f z := by
  have H := taylorSeries_eq_of_entire' hf 0 z
  have hz' := eq_re_of_ofReal_le hz
  rw [hz'] at hz H ‚ä¢
  obtain ‚ü®D, hD‚ü© : ‚àÉ D : ‚Ñï ‚Üí ‚Ñù, ‚àÄ n, 0 ‚â§ D n ‚àß iteratedDeriv n f 0 = D n
  ¬∑ refine ‚ü®fun n ‚Ü¶ (iteratedDeriv n f 0).re, fun n ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ have := eq_re_of_ofReal_le (h n) ‚ñ∏ h n
      norm_cast at this
    ¬∑ rw [eq_re_of_ofReal_le (h n)]
  simp_rw [‚Üê H, hD, ‚Üê ofReal_nat_cast, sub_zero, ‚Üê ofReal_pow, ‚Üê ofReal_inv, ‚Üê ofReal_mul,
    ‚Üê ofReal_tsum]
  norm_cast
  refine tsum_nonneg fun n ‚Ü¶ ?_
  norm_cast at hz
  have := (hD n).1
  positivity

/-- An entire function whose iterated derivatives at zero are all nonnegative real is
monotonic on the nonnegative real axis. -/
theorem monotoneOn_of_iteratedDeriv_nonneg {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : Differentiable ‚ÑÇ f)
    (h : ‚àÄ n, 0 ‚â§ iteratedDeriv n f 0) : MonotoneOn (f ‚àò ofReal') (Set.Ici (0 : ‚Ñù)) := by
  let D : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ (iteratedDeriv n f 0).re
  have hD (n : ‚Ñï) : iteratedDeriv n f 0 = D n
  ¬∑ refine Complex.ext rfl ?_
    simp only [ofReal_im]
    exact (le_def.mp (h n)).2.symm
  obtain ‚ü®F, hFd, hF‚ü© := realValued_of_iteratedDeriv_real hf hD
  rw [hF]
  refine monotone_ofReal.comp_monotoneOn <| (convex_Ici 0).monotoneOn_of_deriv_nonneg
    hFd.continuous.continuousOn hFd.differentiableOn fun x hx ‚Ü¶ ?_
  have hD' (n : ‚Ñï) : 0 ‚â§ iteratedDeriv n (deriv f) 0
  ¬∑ rw [‚Üê iteratedDeriv_succ']
    exact h (n + 1)
  have hf' := (contDiff_succ_iff_deriv.mp <| hf.contDiff (n := 2)).2.differentiable rfl.le
  have hx : (0 : ‚ÑÇ) ‚â§ x
  ¬∑ norm_cast
    simp only [Set.nonempty_Iio, interior_Ici', Set.mem_Ioi] at hx
    exact hx.le
  have H := nonneg_of_iteratedDeriv_nonneg hf' hD' hx
  rw [‚Üê deriv.comp_ofReal hf.differentiableAt] at H
  change 0 ‚â§ deriv (f ‚àò ofReal') x at H
  erw [hF, deriv.ofReal_comp] at H
  norm_cast at H

/-- An entire function whose iterated derivatives at zero are all nonnegative real (except
possibly the value itself) has values of the form `f 0 + nonneg. real` along the nonnegative
real axis. -/
theorem at_zero_le_of_iteratedDeriv_nonneg {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : Differentiable ‚ÑÇ f)
    (h : ‚àÄ n ‚â† 0, 0 ‚â§ iteratedDeriv n f 0) {z : ‚ÑÇ} (hz : 0 ‚â§ z) : f 0 ‚â§ f z := by
  have h' (n : ‚Ñï) : 0 ‚â§ iteratedDeriv n (f ¬∑ - f 0) 0
  ¬∑ cases n with
  | zero => simp only [iteratedDeriv_zero, sub_self, le_refl]
  | succ n =>
      specialize h n.succ <| succ_ne_zero n
      rw [iteratedDeriv_succ'] at h ‚ä¢
      convert h using 2
      ext w
      exact deriv_sub_const (f 0)
  exact sub_nonneg.mp <| nonneg_of_iteratedDeriv_nonneg (hf.sub_const (f 0)) h' hz

/-- An entire function whose iterated derivatives at zero are all real with alternating signs
(except possibly the value itself) has values of the form `f 0 + nonneg. real` along the nonpositive
real axis. -/
theorem at_zero_le_of_iteratedDeriv_alternating {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : Differentiable ‚ÑÇ f)
    (h : ‚àÄ n ‚â† 0, 0 ‚â§ (-1) ^ n * iteratedDeriv n f 0) {z : ‚ÑÇ} (hz : z ‚â§ 0) : f 0 ‚â§ f z := by
  let F : ‚ÑÇ ‚Üí ‚ÑÇ := fun z ‚Ü¶ f (-z)
  convert at_zero_le_of_iteratedDeriv_nonneg (f := F) (hf.comp <| differentiable_neg)
    (fun n hn ‚Ü¶ ?_) (neg_nonneg.mpr hz) using 1
  ¬∑ simp only [neg_zero]
  ¬∑ simp only [neg_neg]
  ¬∑ simpa only [iteratedDeriv.comp_neg, neg_zero] using h n hn

end Complex
